%\documentclass[xcolor=dvipsnames]{beamer}
\documentclass[xcolor=dvipsnames,handout]{beamer}

\input{macros2006}



\newcommand{\titulos}[2]{\frametitle{#1}\framesubtitle{#2}}
\newcommand{\espc}{\vspace{.5cm}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\cv}{\ensuremath{\varepsilon}}
\newcommand{\sest}{\ensuremath{\Sigma^\star}}
\newtheorem{teorema}{Teorema}
\renewcommand{\S}{\Sigma}
\newcommand{\de}{\delta}
\newcommand{\izq}{\leftarrow}
\newcommand{\der}{\rightarrow}
\newcommand{\dest}{\ensuremath{\delta^\star}}

\newcommand{\blanks}{\mbox{\textvisiblespace}}


\mode<presentation>
{
\usetheme[secheader]{Boadilla}
%\useinnertheme{rounded}
\useoutertheme{infolines}
%\usepackage{BeamerColor}
%\usecolortheme[RGB={33,66,33}]{structure}
\usecolortheme[named=NavyBlue]{structure}
%\usefonttheme{}
\setbeamercovered{invisible}
%\setbeamertemplate{headline}{\insertshortinstitute}
%\setbeamertemplate{footline}[page number]{\insertshortinstitute}
%\insertshortinstitute
}

\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}


\title[AyLF MCIC 2016-1]{Autómatas y Lenguajes Formales 2016-1}
\subtitle
{Maestría en Ciencia e Ingeniería de la Computación UNAM\\
  Tema 14:  Máquinas de Turing y computabilidad}

\author[Favio E. Miranda Perea]{Dr. Favio Ezequiel Miranda Perea \\ \texttt{favio@ciencias.unam.mx}}


\institute[FC UNAM]{Facultad de Ciencias UNAM}

\date{\today}

\subject{Theoretical Computer Science}

% \pgfdeclareimage[height=0.5cm]{LogoTecBueno}{LogoTecBueno.eps}
\logo{\includegraphics[height=1cm]{fc2.png}}




\begin{document}

\beamerdefaultoverlayspecification{<+->}

\begin{frame}
  \titlepage
\end{frame}





%\section{Recapitulación}
%%\begin{frame}
%%  \titulos{Sesión Anterior}{}

%\begin{frame}
%  \titulos{Sesión anterior}{}
%  \bi
%    \item Discusión del concepto de \emph{algoritmo}.\espc
%      \item Máquinas de Turing:\espc
%        \bi
%        \item MT como aceptadoras de lenguajes.\espc
%          \item MT como generadoras de lenguajes.\espc
%            \item MT como calculadoras de funciones.
%        \ei
%  \ei
%\end{frame}



%\subsection{La Tesis de Church-Turing}
%\begin{frame}
%  \titulos{La Tesis de Church-Turing}{Introducción}
%  \bi
%  \item La tesis de Church-Turing afirma que la noción intuitiva de
%    algoritmo es capturada de manera exacta por la noción matemática
%    de máquina de Turing.
%    \item Tesis de Church-Turing:
%      \bc
%      \emph{Un problema es soluble algorítmicamente si y sólo si es
%        soluble mediante una máquina de Turing}
%      \ec
%      \item Es decir, las máquinas de Turing implementan a cualquier
%        algoritmo.
%        \item Equivalentemente, una función es computable si y sólo si
%          es soluble mediante una máquina de Turing.
%          \ei
%          \end{frame}


%\subsection{Computabilidad y Complejidad}

%\begin{frame}
%  \titulos{Computabilidad y Complejidad}{Introducción}
% \bi
% \item Aceptamos la tesis de Church-Turing bajo la cual nos interesa
%   discutir los siguiente para un problema específico $\Pe$.
%   \item Computabilidad:  ?`Es $\Pe$
%     efectivamente computable?, es decir, ?` Podemos resolver $\Pe$ mediante una máquina
%     de Turing ?
%   \item Complejidad: ?`Es $\Pe$ eficientemente computable?, es decir,
%     ?`Puede $\Pe$ calcularse o implementarse de manera eficiente?
% \ei
%\end{frame}


%\begin{frame}
%  \titulos{Computabilidad}{Observaciones}
%  \bi
%  \item Tesis CT: Las MT pueden computar todo lo que es computable.
%    \item Existe solamente un número infinito numerable de MT.
%      \item El número de funciones digamos $f:\N\imp\N$ {\bf no} es
%        numerable, es decir, hay más funciones que máquinas de Turing.
%        \item Deben existir funciones no computables.
%          \item Ejemplo prominente: el problema de la detención
%            (\emph{Halting problem})
%  \ei
%\end{frame}


%\begin{frame}
%  \titulos{Complejidad}{Observaciones}

%  \bi
%  \item La complejidad es acerca de los problemas no de las
%    soluciones. 
%    \item La pregunta de interés es ?`Qué tan complejo es resolver el
%      problema? y {\bf no} ?`Qué tan complejo es implementar la solución?
%        \item La complejidad se divide en clases de problemas que
%          comparten ciertas características computacionales.
%          \item {\bf P}: problemas que pueden resolverse por una MT en
%            tiempo polinomial.
%            \item {\bf NP}: problemas que pueden resolverse por una MT
%              no-determinística en tiempo polinomial.
%             % \item $P$ vs. $NP$.
%  \ei
%\end{frame}








%\subsection{Lenguajes Recursivos y R.E.}

% \begin{frame}
%  \titulos{Lenguajes recursivos y recursivamente
%    enumerables}{Aceptación en MT}
% \bi
% \item Un lenguaje $L$ es \alert{recursivamente enumerable} si es reconocido
%  por una máquina de Turing, es decir, si existe una máquina de Turing
%  $M$ tal que $L=L(M)$.\espc
%  \item un lenguaje $L$ es \alert{recursivo} si es reconocido por una máquina
%    de Turing que siempre se detiene, es decir, si existe una máquina
%    de Turing $M$ que se detiene con todas las cadenas de entrada y $L=L(M)$.
% \ei
% \end{frame}



\begin{frame}
  \titulos{Lenguajes recursivos}{}% y recursivamente enumerables}{}
 % \begin{itemize}
%  \item El nombre de estos lenguajes se debe a las siguientes propiedades:
    \begin{itemize}
 \item Un lenguaje $L$ es \alert{recursivo} si es reconocido por una máquina
   de Turing que siempre se detiene, es decir, si existe una máquina
   de Turing $M$ que se detiene con todas las cadenas de entrada y $L=L(M)$.
\item Los lenguajes recursivos también se conocen como Turing-decidibles.
       \item El adjetivo ``recursivo'' se debe a la siguiente propiedad de estos lenguajes: 
\begin{itemize}
\item[] Un lenguaje $L$ es recursivo si y sólo si su función característica $\chi_L$ es recursiva. 
\end{itemize}
\item Esto implica que existe un algoritmo para decidir si una cadena pertenece a $L$.
\end{itemize}
\end{frame}


\begin{frame}
  \titulos{Lenguajes recursivamente enumerables}{}% y recursivamente enumerables}{}
 % \begin{itemize}
%  \item El nombre de estos lenguajes se debe a las siguientes propiedades:
    \begin{itemize}
\item Un lenguaje $L$ es \alert{recursivamente enumerable} si es reconocido
 por una máquina de Turing, es decir, si existe una máquina de Turing
 $M$ tal que $L=L(M)$.\espc
\item Los lenguajes recursivamente enumerables también se conocen como Turing-reconocibles o semidecidibles
       \item El adjetivo ``recursivamente'' se debe a la siguiente propiedad de estos lenguajes: 
\begin{itemize}
\item[] Un lenguaje $L$ es recursivamente enumerable si y sólo si $L$ es la imagen de una función recursiva total.
\end{itemize}
\item Esto implica que existe un procedimiento para decidir si una cadena pertenece a $L$.
\end{itemize}
\end{frame}


\begin{frame}
  \titulos{Lenguajes recursivos}{Enumeración}% y recursivamente enumerables}{}
 % \begin{itemize}
%  \item El nombre de estos lenguajes se debe a las siguientes propiedades:
    \begin{itemize}
    \item Si un lenguaje $L$ es recursivo entonces existe un proceso de enumeración para $L$. 
    \item Es decir, existe un proceso que genera todas las cadenas de $L$.
    
    \item Una máquina que enumera a $L$ se construye componiendo una máquina $M$ que genere a todas las cadenas del alfabeto de entrada, con una máquina $N$ que reconozca a $L$.
    \item El proceso de enumeración consiste en repetir los siguientes pasos:
      \begin{itemize}
      \item $M$ genera a  $w$
      \item $N$ verifica si $w\in L$, en caso positivo se imprime $w$, en otro caso se ignora a $w$.
      \end{itemize}
    \item Este procedimiento funciona pues $N$ siempre se detiene.
    % \item Un lenguaje $L$ es recursivamente enumerable si y sólo si existe un proceso de enumeración para $L$.
    \end{itemize}
   
 % \end{itemize}

\end{frame}


\begin{frame}
  \titulos{Lenguajes recursivamente enumerables}{Enumeración}% y recursivamente enumerables}{}
 % \begin{itemize}
%  \item El nombre de estos lenguajes se debe a las siguientes propiedades:
    \begin{itemize}
    \item Un lenguaje $L$ es recursivamente enumerable si y sólo si existe un proceso de enumeración para $L$. 
%    \item Es decir, existe un proceso que genera todas las cadenas de $L$.
    \item El proceso de enumeración para un lenguaje recursivo no funciona aquí. Se debe combinar la ejecución de $M$ y $N$ de otra manera. 
    % \item Una máquina que enumera a $L$ se construye componiendo una máquina $M$ que genere a todas las cadenas del alfabeto de entrada, con una máquina $N$ que reconozca a $L$.
    \item El proceso de enumeración consiste en repetir los siguientes pasos:
      \begin{itemize}
      \item $M$ genera a la $i$-ésima cadena  $w_i$
      \item $N$ ejecuta un paso (transición) en $w_i$, dos pasos en $w_{i-1}$, tres pasos en $w_{i-2}$, y así sucesivamente.
      \item Si en algún momento $N$ acepta a $w_i$, se imprime dicha cadena.
%i$-pasos (transiciones) en $w, en caso positivo se imprime $w$, en otro caso se ignora a $w$.
      \end{itemize}
    \item Este procedimiento funciona pues $N$ va procesando en tiempo finito fragmentos de cada cadena $w_i$
    % \item Un lenguaje $L$ es recursivamente enumerable si y sólo si existe un proceso de enumeración para $L$.
    \end{itemize}
   
 % \end{itemize}

\end{frame}




\begin{frame}
  \titulos{?`Qué es un algoritmo?}{Introducción}
  \bi
  \item ?`Qué es un algoritmo?\espc
    \item Podemos reconocer cuando vemos un algoritmo.\espc
      \item ?`Podemos dar una definición precisa del concepto de
        algoritmo?\espc
        \item ?`Por qué es importante tener una definición precisa
          (matemática) de algoritmo?
  \ei
\end{frame}


\begin{frame}
  \titulos{?`Qué es un algoritmo?}{Introducción}
  \bi
  \item Un algoritmo es una colección de instrucciones simples para
    realizar una tarea o problema particular (procedimientos o recetas)\espc
\item Si se tiene un algoritmo para un problema dado $P$ significa
  tener una manera para calcular efectivamente o resolver $P$.\espc
  \item Un algoritmo es un proceso \alert{potencialmente} realizable
    \bi
    \item Las operaciones del proceso se pueden realizar
      inequívocamente.\espc
      \item El número de operaciones o pasos del proceso es finito.
        \ei

  \ei
\end{frame}

%\subsection{Existencia y Formalización}
\begin{frame}
  \titulos{Existencia de algoritmos}{Introducción}
  \bi
  \item Décimo problema de Hilbert: Hallar un proceso de acuerdo al
    cual pueda determinarse en un número finito de pasos (un
    algoritmo) si un polinomio dado tiene una raiz entera.\espc
    \item Se creia que todo problema $P$ tenia una solución
      algorítmica.\espc
      \item Más aún se pensaba en la existencia de un algoritmo
        universal $U$ que pudiera resolver todos los problemas
        matemáticos.
\ei
      \end{frame}

\begin{frame}
  \titulos{Existencia de algoritmos}{Introducción}
         \bi
        \item Los intentos por hallar el algoritmo universal $U$ fallaron.\espc
          \item Tal vez $U$ no existía.\espc
            \item ?`Cómo probar la no existencia de $U$?\espc
              \item Era necesario definir el concepto de algoritmo de
                una manera precisa y hallar un formalismo para poder probar propiedades de
                los mismos.\espc
                \item Un formalismo de algoritmos deberia ser preciso
                  y libre de ambigüedades, simple y general.
        \ei
\end{frame}


\begin{frame}
  \titulos{Formalización del concepto de algoritmo}{Introducción}
 \bi
 \item Máquinas de Turing (Alan Turing, Cambridge 1936)\espc
   \item Cálculo Lambda (Alonzo Church, Princeton 1936)\espc
     \item Sistemas de Post (Emile Post)\espc
       \item Funciones $\mu$-recursivas (Gödel, Herbrand, Kleene)\espc
         \item Lógica Combinatoria (Curry, Schönfinkel)\espc
           \item Máquinas de registro (Sheperdson, Sturgis)
 \ei
\end{frame}


\begin{frame}
  \titulos{Equivalencia de los formalismos}{Introducción}
\bi
\item Sorprendentemente todos los formalismos han resultado
    equivalentes.\espc
    \item Un problema tiene solución en un formalismo si y sólo si
      tiene solución en cualquiera de los otros.\espc
      \item Tal afirmación es un teorema, o una serie de teoremas
        rigurosamente demostrados.\espc
        \item Esta coincidencia nos lleva a conjeturar que existe una
          única noción de computabilidad.\espc
      \ei
\end{frame}

%\subsection{La Tesis de Church-Turing}
\begin{frame}
  \titulos{La Tesis de Church-Turing}{Introducción}
  \bi
  \item La tesis de Church-Turing afirma que la noción intuitiva de
    algoritmo es capturada de manera exacta por la noción matemática
    de máquina de Turing.\espc
    \item Tesis de Church-Turing:
      \bc
      \emph{Un problema es soluble algorítmicamente si y sólo si es
        soluble mediante una máquina de Turing}
      \ec \espc
      \item Es decir, las máquinas de Turing implementan a cualquier
        algoritmo.\espc
        \item Equivalentemente, una función es computable si y sólo si
          es soluble mediante una máquina de Turing.
          \ei
          \end{frame}

          \begin{frame}
  \titulos{La Tesis de Church-Turing}{Introducción}
   \bc
      \emph{Un problema es soluble algorítmicamente si y sólo si es
        soluble mediante una máquina de Turing}
      \ec\pause
          \bi
          \item La afirmación es una tesis indemostrable pues la
            noción de algoritmo es intuitiva.\espc
            \item Por otro lado la tesis es refutable y se destruiría
              mostrando un algoritmo que no pudiera ser implementado
              en una máquina de Turing.
\ei
\end{frame}
\begin{frame}
  \titulos{Tesis de Church-Turing}{Evidencias a favor}
  \bi
  \item Existen fuertes evidencias a favor de la tesis.\espc
  \item Intuitivamente cualquier algoritmo detallado para el cálculo
    manual puede programarse en una MT.\espc
    \item La equivalencia con otros formalismos mas modernos.\espc
      \item Existen demasiados ejemplos a favor y por supuesto ningún
        contraejemplo.\espc
        \item La comunidad tanto en matemáticas como en ciencias de la
          computación acepta ampiamente la tesis.
  \ei
\end{frame}



%\subsection{La Maquina Universal}
%\subsection{Introducción}

\begin{frame}
  \titulos{Máquinas de Turing vs. Computadoras}{} %{Introducción}
  \bi
  \item Una computadora es capaz de interpretar algoritmos arbitrarios
    y obtener la misma respuesta que cada algoritmo particular.\medskip
    \item Entonces una computadora es una máquina útil para
      propósitos generales.\medskip
      \item Las MT en cambio son diseñadas para propositos
        particulares.\medskip
        \item Conclusión: el poder computacional de las MT  no puede
          ser equiparable al de las computadoras actuales.\medskip
          \item Las computadoras son programables, las MT no.
  \ei
\end{frame}

\begin{frame}
  \titulos{La Maquina Universal de Turing}{Introducción}
  \bi
  \item ?`Será factible pensar en la existencia de una MT que se
    comporte de la misma forma que una computadora real?\espc
    \item Es decir, una MT que sea útil para propósitos multiples.\espc
      \item Dicha máquina sería capaz de programar y ejecutar máquinas
        de Turing.
  \ei
\end{frame}


\begin{frame}
  \titulos{La Máquina Universal de Turing}{Introducción}
  \bi
  \item Tal máquina existe y se conoce como máquina universal de
    Turing (MUT).\espc
    \item La MUT recibe como entrada una descripción de una MT, $M$ y
      una cadena $w$ y simula el comportamiento de $M$ sobre $w$.\espc
      \item Los datos de entrada $M$ y $w$ deben ser codificados de
        manera adecuada.
  \ei
\end{frame}

%\subsection{Codificación de MT}
\begin{frame}
  \titulos{Codificación de MT}{Convenciones}
  \bi
  \item Se fija un alfabeto de entrada $\S$.
    \item Se asume $Q=\{q_0,\ldots,q_n\}$ siendo $q_0$ el estado inicial y
      $q_1$ el {\bf único} estado final.
      \item El alfabeto de cinta es de la forma
        \beqs
        \G=\{s_1,s_2,\ldots, s_p\}
        \eeqs
        siendo $s_1=\bot$.
  \ei
\end{frame}

\begin{frame}
  \titulos{Alfabeto de Cinta}{Codificación de MT}
        \beqs
        \G=\{s_1,s_2,\ldots, s_p\}
        \eeqs\pause
 \bi
 \item El símbolo $s_i$ se codifica como $1^i$.
   \item Las cadenas $\G^\star$ se codifican separando cada símbolo
     con $0$.
  \item Por ejemplo, si $\G=\{\bot,a,b\}$ entonces codificamos
    $\bot:=1,\;a:=11,\;b:=111$.
    \item La palabra $bab\bot aa$ se codifica como:
      \beqs
      01110110111010110110
      \eeqs
 \ei
\end{frame}

\begin{frame}
  \titulos{Alfabeto de Cinta}{Codificación de MT}
  \beqs
        \G=\{s_1,s_2,\ldots, s_p\}
        \eeqs \pause
  \bi 
  \item En general, si $w=s_{n_1}s_{n_2}\ldots s_{n_k}$ la
    codificación de $w$ es:
    \beqs
    01^{n_1}01^{n_2}0\ldots 01^{n_k}0
    \eeqs
  \ei
\end{frame}


\begin{frame}
  \titulos{Estados}{Codificación de MT}
  \beqs
  Q=\{q_0,q_1,\ldots,q_n\}
  \eeqs \pause
  \bi
  \item El estado $q_i$ se codifica, análogamente a los
    símbolos, mediante cadenas de unos pero con un símbolo más que el
    índice del estado
    \beqs
    q_i\;\mbox{se codifica como}\;1^{i+1}
    \eeqs
    \item Con la convención tomada, el estado inicial $q_0$ se codifica con
      $1$ y el estado final $q_1$ con $11$.
  \ei
\end{frame}


\begin{frame}
  \titulos{Direcciones de desplazamiento}{Codificación de MT}
  \beqs
  \{\der,\izq, -\}
  \eeqs

  \bi
  \item $\der$ se codifica con $1$.\espc
    \item $\izq$ se codifica con $11$.\espc
      \item $-$ se codifica con $111$.
  \ei
\end{frame}

\begin{frame}
  \titulos{Transiciones}{Codificación de MT}
  \beqs
  \de(q_i,s_k)=(q_j,b_\ell,D)
  \eeqs\vspace{-0.5cm}
  \bi
  \item Los estados, símbolos y dirección de desplazamiento se codifican de la manera
    indicada anteriormente.
    \item La transición se codifica escribiendo en orden los códigos
      respectivos separados por ceros:
      \beqs
      01^{i+1}01^k01^{j+1}01^\ell01^n0
      \eeqs
      donde $n=1,2,3$.
      \item Por ejemplo $\de(q_2,s_3)=(q_0,s_5,\izq)$ se codifica como
        \beqs
        01^301^30101^501^20
        \eeqs
  \ei
\end{frame}


\begin{frame}
  \titulos{Máquinas de Turing}{Codificación de MT}
  \bi
  \item Una MT queda completamente determinada mediante su función de
    transición $\de$.
    \item La MT se codifica mediante la sucesión de los códigos de
      sus transiciones sin separaciones. Es decir, si $C_1,\ldots,C_k$
      son los códigos de todas las transiciones de $M$. Entonces $M$
      se codifica mediante
      \beqs
      C_1C_2\ldots C_k
      \eeqs
      \item Obsérvese que no hay ambigüedad pues cada transición tiene
        exactamente seis ceros, además dos ceros consecutivos indican
        que inicia otra transición.
  \ei
\end{frame}


\begin{frame}
  \titulos{Codificación de MT}{Ejemplo}
  La máquina $M$ dada por:
  \beqs
  \de(q_0,a)=(q_2,b,\der)\;\;\;\;\;\de(q_2,b)=(q_3,c,\der) 
  \eeqs
  \beqs
  \de(q_3,a)=(q_1,c,\der)\;\;\;\;\;\de(q_1,b)=(q_3,\bot,-) 
  \eeqs
  se codifica mediante $a:=11,\;b:=111,c:=1111$ como sigue:
  \beqs
  0101101110111010011101110111101111010
\eeqs
\beqs
  01111011011011110100110111011110101110
  \eeqs
\end{frame}


\begin{frame}
  \titulos{Codificación de MT}{Observaciones}
  \bi
  \item La codificación de una MT no es única, puesto que el orden de
    las transiciones no importa y un orden distinto genera una codificación
    distinta.\espc
    \item De hecho si $M$ tiene $n$ transiciones, existen $n!$
      codificaciones distintas para $M$.\espc
      \item El proceso de codificación puede revertirse, no es dificil
        definir un algoritmo que decida si una secuencia binaria
        representa un código válido para MT y en tal caso lo decodifique.
  \ei
\end{frame}

%\subsection{Enumerabilidad de las MT}
\begin{frame}
  \titulos{Enumerabilidad de las MT}{}
  \bi
  \item En conclusión toda MT puede representarse como una cadena
    binaria.\medskip
    \item No todas las cadenas binarias representan MT válidas, por
      ejemplo, las cadenas que empiezan o terminan con $1$ o las que
      tienen más de dos ceros consecutivos.\medskip
      \item Cada cadena binaria, representa por otra parte un número
        natural y viceversa. Es decir, hay tantas cadenas binarias
        como números  naturales.\medskip
        \item De lo anterior se concluye que hay sólo un número
          numerable de MT.
  \ei
\end{frame}


\begin{frame}
  \titulos{Enumerabilidad de las MT}{}
  \bi
  \item Las cadenas binarias pueden enumerarse en orden lexicográfico
    con $0<1$:
    \beqs
    0,1,00,01,10,11,000,001,010,011,100,101,110,111,\ldots
    \eeqs
    \item Cada MT figura varias veces en esta lista.\medskip
      \item Por motivos prácticos si una cadena no codifica
        directamente a una MT entonces acordamos que codifica a la
        máquina sin transiciones que acepta el lenguaje vacío.\medskip
        \item De esta manera cada cadena binaria codifica a una MT.
  \ei
\end{frame}


\begin{frame}
  \titulos{Existencia de funciones no computables}{Enumerabilidad de
    MT}
  \bi
  \item Dado que las cadenas binarias son tantas como los números
    naturales y cada cadena codifica a una MT concluimos que sólo hay
    un número infinito numerable de MT.
    \item Por otro lado si consideramos las funciones $f:\N\imp \N$ es
      bien sábido que son un número {\bf no} numerable (tantas como
      números reales)
      \item De donde se concluye que existen funciones, que {\bf no}
        pueden calcularse mediante una MT.
        \item Lo cual bajo la tesis de Church-Turing equivale a que
          existen funciones que no pueden ser calculadas mediante una computadora.
  \ei
\end{frame}


%\subsection{Descripción y funcionamiento de MUT}

% \begin{frame}
%   \titulos{La Máquina Universal de Turing $\U$}{Descripción}
%   \bi
%   \item La máquina universal de Turing $\U$ simula el comportamiento
%     de cualquier MT sobre un alfabeto $\S$ dado.
%     \item $\U$ recibe como entrada (el código de) una máquina $M$ y una
%       cadena $w$
%       \item Los datos de entrada se representan como $M0w$, es decir,
%         la entrada es una cadena binaria que consta del código de $M$
%         y el código de $w$ en orden separados por un cero.
%         \item En tal caso la cadena tiene una única sucesión de tres
%           ceros que separa a $M$ y $w$.
%   \ei
% \end{frame}


% \begin{frame}
%   \titulos{La Máquina Universal de Turing $\U$}{Descripción}
%   \bi
%   \item $\U$ es una máquina con tres cintas y alfabeto
%     $\G=\{0,1,\bot\}$.\espc
%     \item La primera cinta recibe el código de una máquina cualquiera
%       $M$.\espc
%       \item La segunda cinta recibe el código de una cadena $w$.\espc
%         \item La tercera cinta almacena el código del estado actual de $M$ 
%   \ei
% \end{frame}


% \begin{frame}
%   \titulos{La Máquina Universal de Turing $\U$}{Funcionamiento}
%   \bi
%   \item $\U$ examina el código de $M$ para saber si es una máquina
%     válida, en caso contrario $\U$ para sin aceptar.\espc
%     \item $\U$ lee las cintas dos y tres para buscar en la cinta uno
%       la transición necesaria.\espc
%       \item Se aplica la transición modificando la cadena en la cinta
%         dos y cambiando el estado en la cinta 3, como $M$ lo haría. La
%         unidad de control vuelve a la primera posición en las cintas
%         uno y tres.
        
%   \ei
% \end{frame}


% \begin{frame}
%   \titulos{La Máquina Universal de Turing $\U$}{Funcionamiento}
%   \bi
%   \item Si al procesar $w$ $\U$ se detiene en el único estado de
%     aceptación entonces se acepta $w$, como el estado de aceptación es
%     el mismo que el de $M$ entonces $M$ tambien aceptaba a $w$.\espc
%     \item Si no hay transición aplicable en la cinta uno o si $\U$ se
%       detiene en un estado distinto al de aceptación $w$ no se acepta,
%       al igual que en $M$.\espc
%       \item $\U$ acepta a $w$ si y sólo si $M$ acepta a $w$.
%   \ei
% \end{frame}

%\subsection{Lenguaje universal y diagonal}


\begin{frame}
  \titulos{El lenguaje diagonal $\mathcal{L}_D$}{}
  \bi
  \item Consideremos la enumeración de las máquinas de Turing
    $M_1,M_2,\ldots$ así como la enumeración de todas las cadenas de
    $\sest$, digamos $w_1,w_2,\ldots,w_n,\ldots$.\medskip
  \item Podemos entonces dar como entrada la $i$-ésima palabra $w_i$ a
    la $i$-ésima máquina $M_i$.\medskip
    \item El lenguaje diagonal se define como:
      \beqs
      \mathcal{L}_D=\{w_i\;|\;w_i\;\mbox{no es aceptada por}\;M_i\}
      \eeqs%\medskip
      \item Es decir $\mathcal{L}_D$ contiene a la $i$-ésima cadena
        si y sólo si ésta no es aceptada por la $i$-ésima máquina. 
  \ei
\end{frame}



\begin{frame}
  \titulos{$\mathcal{L}_D$ \alert{no} es recursivamente enumerable}{}
  \bi
  \item Si $\mathcal{L}_D$ fuera R.E. sería aceptado por una MT,
    digamos la $k$-ésima máquina $M_k$.\medskip
    \item En tal caso $\mathcal{L}_D=L(M_k)$.\medskip
      \item Podemos preguntarnos entonces si $w_k\in \mathcal{L}_D$.
        \bi
        \item $w_k\in\mathcal{L}_D\Imp w_k$ no es aceptada por
          $M_k\Imp w_k\notin L(M_k)=\mathcal{L}_D$.
          \item $w_k\notin\mathcal{L}_D\Imp
            w_k\notin\mathcal{L}_D\Imp$ $w_k$ es aceptada por $M_k\Imp
            w_k\in L(M_k)=\mathcal{L}_D$.
        \ei
        \item Por lo que se tendría \beqs w_k\in\mathcal{L}_D\;\mbox{ si y sólo si
          }\;w_k\notin\mathcal{L}_D\eeqs
          \item Lo cual es absurdo.
          
  \ei
\end{frame}



\begin{frame}
\titulos{El lenguaje universal $\mathcal{L}_\U$}{Definición}
\begin{itemize}
\item El lenguaje aceptado por la máquina universal $\U$ se conoce
  como lenguaje universal, denotado $\mathcal{L}_\U$.
\beqs
\mathcal{L}_\U=\{\pt{M}0\pt{w}\;|\;M\;\mbox{acepta a }\;w\}
\eeqs
\item Por definición $\mathcal{L}_\U$ es un lenguaje recursivamente enumerable.
\end{itemize}
\end{frame}


% \begin{frame}
%   \titulos{Lenguajes Recursivos y R.E.}{}
%   \bi
%   \item Todo lenguaje recursivo es recursivamente enumerable.\espc
%     \item  Existen lenguajes recursivamente enumerables que no son
%       recursivos. En particular el lenguaje universal $\mathcal{L}_\U$
%       no es recursivo.\espc
%       \item Existen lenguajes no recursivamente enumerables como
%         $\mathcal{L}_D$.
%       \ei
% \end{frame}



\begin{frame}
\titulos{El lenguaje universal $\mathcal{L}_\U$ no es recursivo}{}

        Supongamos lo contrario y sea $M$ una máquina de Turing que
        siempre se detiene y tal que $\mathcal{L}_\U=L(M)$.\\
       Veamos que a partir de $M$ podemos construir una máquina de
       Turing $M'$ que acepte al lenguaje diagonal $\mathcal{L}_D$, lo
       cual es absurdo.\\
       $M'$ funciona como sigue para la entrada $w\in\sest$:
\bi
\item Enumerar las cadenas de $\sest$ hasta encontrar $k\in\N$ tal que
  $w=w_k$.
\item Llamar a $M$ con entrada $\pt{M_k}0\pt{w_k}$.
\item Como $M$ siempre se detiene entonces decide si $M_k$ acepta a
  $w_k$
\item En tal caso forzamos a que $M'$ acepte también a $w_k$. 
\item Esto implica que $L(M')=\mathcal{L}_D$. Un absurdo.
\ei
\end{frame}


% %\section{Computabilidad}

% %\subsection{Introducción}
\begin{frame}
  \titulos{Preguntas y Problemas}{Introducción}
  \bi
  \item Preguntas:
    \bi
    \item ?`Qué $x$ real cumple $2x^2-3x+5=0$?\medskip
      \item Dadas las ciudades $a,b,c,d$ ?`Cual es la forma óptima de
        visitarlas sin pasar dos veces por la misma ciudad?
    \ei\medskip
    \item Una problema es una clase de preguntas:
      \bi
      \item ?`Cuales son las soluciones de ?`$ax^2+bx+c=0$?\medskip
      \item ?` Dados $n$ vértices en un grafo existira un camino hamiltoniano?
      \ei\medskip
    \item Cada caso particular de un problema es un ejemplo, ejemplar o
      instancia de éste. 
  \ei
\end{frame}


\begin{frame}
  \titulos{Tipos de Problemas}{Introducción}

\bi
\item La mayoría de los problemas de interén en ciencias de la
  computación son de dos tipos.
  \item Problemas de cómputo: obtener el valor de una función en un
    argumento dado.
    \bi
    \item Por ejemplo obtener la raiz cuadrada de un número dado $x$
      con exactitud de milésimas.
    \ei
    \item Problemas de decisión: estos problemas tienen como respuesta
      si o no.
      \bi
    \item Por ejemplo, decidir la existencia de un camino óptimo en costos para
      recorrer varias ciudades.
    \ei
    \item Si bien los problemas de decisión también podrían
      considerarse problemas de cómputo, es útil hacer la distinción.
\ei
  
\end{frame}

%\subsection{Algoritmos y problemas}
\begin{frame}
  \titulos{Algoritmos y problemas}{}
  \bi
  \item Un algoritmo para un problema consiste de una serie de
    instrucciones capaces de responder cualquier instancia del
    problema dado.\medskip
    \item Un problema $P$ se dice soluble si existe un algoritmo para
      $P$. En otro caso se dice insoluble.\medskip
      \item Si un problema de decisión $P$ es soluble entonces decimos que
        $P$ es decidible. En caso contrario el problema se dice
        indecidible.\medskip
        \item Un proceso o algoritmo para un problema de decisión se
          conoce como un proceso o algoritmo de decisión.
  \ei
\end{frame}


\begin{frame}
  \titulos{Algoritmos y funciones}{}
  \bi
  \item Cualquier algoritmo puede verse como una función:
    \beqs
    \mbox{entrada}\;x \imp \;\mbox{algoritmo}\; \imp \; \mbox{salida}\; y
    \eeqs
    \item La salida está en función de la entrada
      \beqs
      f(x)=y
      \eeqs
      \item Una función es computable si existe un algoritmo que la
        calcule.
        \item La teoría de la computabilidad se encarga esencialmente
          a contestar la pregunta \alert{?`Qué funciones son computables?}
          \item Lo cual equivale entonces a responder que problemas
            son solubles.
  \ei
\end{frame}

%\subsection{Problemas no computables}
\begin{frame}
  \titulos{Problemas no computables}{Introducción}
  \bi
  \item ?`Por qué nos interesa averiguar qué problemas no son
    computables mediante un algoritmo o proceso?\medskip
    \item Tales problemas son aquellos que {\bf no} podemos resolver.\medskip
      \item Son resultados fundamentales y debemos conocerlos para
        tener una visión general de las ciencias de la computación.\medskip
        \item Debemos conocerlos para evitar intentar resolverlos.\medskip
          \item Debemos entender que tales problemas son insolubles
            independientemente del desarrollo futuro del hardware.
  \ei
\end{frame}



\begin{frame}
  \titulos{Recursividad y decidibilidad}{Problemas insolubles}
  \bi
  \item Considérese una propiedad $\Pe$ acerca de máquinas de Turing.\medskip
    \item$\Pe$ genera el problema de decisión siguiente:\\
      \bc
      ?`Satisface la máquina $M$ la propiedad $\Pe$ ?
      \ec
      \item Asumiendo la tesis de Church-Turing, tal problema de
        decisión será decidible (soluble) si y sólo si el lenguaje
        \beqs
        L=\{\pt{M}\;|\;\pt{M}\;\mbox{es el código de una MT que satisface}\;\Pe\}
        \eeqs
        es recursivo.
  \ei
\end{frame}


%\subsection{El problema de la detención}
\begin{frame}
  \titulos{El problema de la detención}{\emph{Halting problem}}

 \bc
 Dada una máquina $M$ y una cadena $w$ ?`Se detendrá $M$ al procesar $w$?
 \ec \pause
\bi
\item El problema sería soluble si pudieramos hallar una máquina $H$
   tal que al recibir como entrada a cualquier cadena $\pt{M}0\pt{w}$ se
   detuviera si y sólo si $M$ se detiene al procesar $w$.\espc
   \item Podría pensarse que una máquina universal puede hacer el
     trabajo.
     \ei
  \end{frame}
\begin{frame}
    \titulos{El problema de la detención}{\emph{Halting problem}}
  \bi
    \item El problema de la detención resulta indecidible, es decir,
       no existe tal máquina $H$.\espc
\item Además es quizas el problema indecidible
  más relevante en la teoría de la computabilidad.\espc
\item Una consecuencia inmediata de su indecidibilidad es que no puede
  existir un programa que verifique si cualquier programa dado se cicla.
\ei
\end{frame}

\begin{frame}
  \titulos{El problema universal}{Problemas no computables}
  \bc
  Dada una máquina de Turing cualquiera $M$ y una cadena $w$\\ ?`Acepta
  $M$ a $w$?
  \ec \pause
  \bi
  \item El problema universal equivale a que el lenguaje universal
    \beqs
     \mathcal{L}_\U=\{\pt{M}0\pt{w}\;|\;M\;\mbox{acepta a}\;w\}
    \eeqs
    sea recursivo.
    \item Ya demostramos que $\mathcal{L}_{\U}$ no es recursivo.
      \item Por lo tanto el problema universal es indecidible.
  \ei
\end{frame}


% \subsection{Reducibilidad de problemas}

\begin{frame}
  \titulos{Reducibilidad de problemas}{}
  \bi
  \item La reducibilidad de problemas es una técnica de gran utilidad
    para probar la indecidibilidad de un problema dado a partir de la
    indedidibilidad de un problema conocido.\espc
    \item Dados dos problemas $\Pe_1,\Pe_2$ decimos que $\Pe_1$ se
      reduce a $\Pe_2$ si un algoritmo para decidir $\Pe_2$ puede
      emplearse para decidir $\Pe_1$.
\ei
\end{frame}

\begin{frame}
  \titulos{Reducibilidad de problemas}{}
  \bi      
      \item Formalmente decimos que $\Pe_1$ se reduce a $\Pe_2$,
        denotado $\Pe_1\prec\Pe_2$ si existe una MT $M$ tal que:\medskip
      \item $M$ recibe como entrada una instancia $I_1$ de $\Pe_1$\medskip
        \item $M$ devuelve como salida una instancia $I_2$ de $\Pe_2$.\medskip
          \item $M$ decide a $I_1$ de la misma manera que $I_2$.\medskip
            \item Es decir, $M$ responde con \emph{sí} a $I_1$ si y sólo si
              responde con \emph{sí} a $I_2$.\medskip
              \item De esta manera se tiene que $\Pe_1$ es decidible
                si y sólo si $\Pe_2$ es decidible.
  \ei
\end{frame}

\begin{frame}\titulos{PD $\prec$ PU}{Reducibilidad}
  \bi
  \item El problema universal puede reducirse al problema de la
    detención
    \item Supongamos que existe una máquina $H$ que decide el
      problema de la detención.
      \item En tal caso $H$ decide también al problema universal.
        \item Al recibir una entrada $\pt{M}0\pt{w}$, $H$ decide si $M$ se
          detiene o no con entrada $w$.
          \item Si $M$ no se detiene con $w$ entonces $M$ no acepta a
            $w$.
            \item Si $M$ se detiene con $w$ entonces $M$ procesa a $w$
              y decide si la acepta o no.
              \item De manera que el problema universal se decide, lo
                cual es absurdo.
  \ei
\end{frame}

\begin{frame}
  \titulos{Otros problemas indecidibles}{Reducibilidad}
  \bi
  \item Detención con cinta en blanco: ?` se detiene la máquina $M$ al
    iniciar con la cinta en blanco?\medskip
    \item Impresión de un símbolo: Dada $M$ y $s\in\S$ ?`Escribirá $M$
      en algún momento a $s$ sobre la cinta?\medskip
      \item Dada una gramática libre de contexto $G$  ?`$G$ es
        ambigua?\medskip
        \item Determinar si dos GLC son equivalentes.\medskip
        \item Cualquier propiedad no trivial acerca de MT (Teorema de Rice) 
  \ei
\end{frame}




% \section{Complejidad}
% \subsection{Introducción}

% \begin{frame}
%   \titulos{Complejidad}{Introducción}
%   \bi
%   \item Las MT son el formalismo más útil en el análisis de
%     algoritmos, debido a que modelan de manera precisa los conceptos
%     centrales de cómputo, almacenamiento, espacio y tiempo.
%     \item La noción formal de cómputo permite precisar sin
%       ambigüedades el tiempo de computación de un problema.
%       \item Las celdas de la cinta formalizan de manera clara la
%         noción de espacio de almacenamiento (memoria)
%         \item Así las nociones de tiempo y espacio se
%           modelan de forma muy realista mediante una MT, lo cual
%           permite analizar la complejidad computacional de un problema. 
%   \ei
% \end{frame}


% \begin{frame}
%     \titulos{Complejidad}{Introducción}
%     \bi
%     \item La teoría de complejidad se interesa por el estudio de la
%       complejidad necesaria para resolver un problema.
%       \item En particular por el consumo de recursos (espacio y
%         tiempo).
%         \item No le conciernen los problemas insolubles.
%           \item Pero tampoco todos los problemas solubles, en la
%             práctica aquellos problemas solubles que no pueden
%             resolverse en un tiempo razonable son tan despreciables
%             como un problema insoluble.
%             \item Los problemas se clasifican en clases de complejidad
%               de acuerdo a que tan dificil es resolverlos.
%      \ei
% \end{frame}

% \begin{frame}
%   \titulos{La función de tiempo de ejecución de una MT}{Complejidad}
%   \bi
%   \item[] La función tiempo de ejecucion de una MT $M$ se define como
%     \beqs t_M:\N\imp\N\cup\{\infty\}\eeqs \espc
%    \item[] $t_M(n):=\;$ máximo número de pasos de ejecución de $M$ para una
%            entrada de longitud $n$.
  
%   \ei
% \end{frame}

% \begin{frame}
%   \titulos{Máquinas que corren en tiempo polinomial}{Complejidad}
%   \bi
%   \item Una máquina de Turing $M$ corre en tiempo polinomial si:
%     \item Existe un polinomio con coeficientes enteros no negativos
%       \beqs p(x)=a_nx^n+a_{n-1}x^{n-1}+\ldots +
%       a_1x+a_0\eeqs 
%       \item tal que $t_M(n)\leq p(n)$ para toda $n\in\N$.
%         \item Es decir, si la función de tiempo de ejecución de $M$
%           está acotada superiormente por un polinomio.
%         \item Una máquina que corre en tiempo polinomial siempre se detiene.
%   \ei
% \end{frame}

% \subsection{Clases de complejidad}
% \begin{frame}
%   \titulos{{\bf P}}{Clases de complejidad}
%   \bi
%   \item Clase de problemas que pueden ser resueltos eficientemente
%     \item Eficientemente significa que existe un algoritmo que corre
%       en \alert{tiempo polinomial}.
%       \item {\bf P} se conoce también como la clase de problemas
%         \alert{tratables}.
%         \item En contraste, un problema es \alert{intratable} si es
%           soluble pero cualquier solución algorítmica corre en tiempo
%           exponencial en el peor de los casos.
%           \item Un problema intratable es prácticamente insoluble,
%             excepto para entradas muy pequeñas, a no ser que el caso
%             promedio sea mucho mejor que el peor caso.
%   \ei
% \end{frame}




% \begin{frame}
%   \titulos{{\bf NP}}{Clases de complejidad}
%   \bi
%   \item Clase de problemas que pueden ser resueltos en tiempo
%     polinomial pero sólo por un algoritmo no determinista.
%     \item Es decir son los problemas solubles por una MT
%       no-determinista en tiempo polinomial.
%       \item Sabemos que las MT no-deterministas equivalen a las MT
%         deterministas.
%         \item Sin embargo no se sabe en general si un problema soluble mediante
%           un algoritmo no-determinista tendrá una solución
%           determinista.
%   \ei
% \end{frame}


% \begin{frame}
%   \titulos{{\bf P} vs {\bf NP}}{Clases de complejidad}
%   \bi
%   \item Dado un problema $\Pe\in\;${\bf NP} en general no sabemos si
%     existirá una solución determinista.
%     \item Si {\bf P} = {\bf NP} entonces la respuesta es afirmativa.
%       \item Aun no se ha probado ni refutado si {\bf P}={\bf NP}.
%         \item En caso positivo siempre habría un algoritmo determinista
%           para un problema cuya solución no-determinista se conoce.
%           \item Se sospecha que {\bf P}$\neq${\bf NP} y esta es la
%             pregunta más importante en la teoria de la complejidad (la
%             respuesta vale 1 millón de dolares)
%   \ei
% \end{frame}
% \subsection{Problemas {\bf NP}-completos}
% \begin{frame}\titulos{Problemas {\bf NP}-completos}{Complejidad}
% \begin{itemize}
% \item Los problemas {\bf NP}-completos son los más dificiles de la
%   clase {\bf NP}.\espc
%   \item Cualquier problema de la clase {\bf NP} puede reducirse a
%     cualquier problema {\bf NP}-completo.\espc
%     \item Existen muchos problemas {\bf NP}-completos, el más
%       relevante es probablemente el problema {\bf SAT} (Teorema de Cook).
% \end{itemize}  
% \end{frame}


% \begin{frame}
%   \titulos{Problemas {\bf NP}-completos}{Complejidad}
% \bi
% \item Un problema $\Pe$ es {\bf NP}-completo ($\Pe\in\;${\bf NPC}) si:
% \bi
% \item $\Pe\in\;${\bf NP}.
%     \item $\mathcal{Q}\prec\Pe$ en tiempo polinomial para cualquier problema
%       $\mathcal{Q}\in{\bf NP}$.
% \ei \espc
% \item Todos los problemas en la clase {\bf NPC} son equivalentes, es
%   decir, si $A,B\in\;${\bf NPC} entonces $A\prec B$ y $B\prec A$.\espc
%   \item La segunda condición de la definición se puede intercambiar
%     por: $C\prec \Pe$ para algún problema {\bf NP}-completo $C$.
% \ei
% \end{frame}

% \begin{frame}
%   \titulos{El problema de satisfacción {\bf SAT}}{Algunos problemas {\bf NP}-completos}
% \bi
% \item Dada una fórmula de la lógica proposicional en forma normal
%   conjuntiva:
%   \beqs
%   P:= C_1\lor C_2\lor C_3\ldots C_n
%   \eeqs
% \item ?`Existe una asignación de verdad que satisfaga a $P$?\espc
%   \item Teorema de Cook (1971): {\bf SAT} es {\bf NP}-completo.\espc
%   \item Este es el primer problema {\bf NP}-completo.
% \ei
% \end{frame}

% \begin{frame}
%   \titulos{Circuito Hamiltoniano {\bf PCH}}{Algunos problemas {\bf NP}-completos}
% \bi
% \item Un circuito hamiltoniano es un cámino que inicia y termina en un
%   mismo vértice de un grafo conexo y que
%   visita a todos los vértices exactamente una vez (el vértice de
%   inicio y fin cuenta solo una vez).\espc
  
%   \item {\bf PCH}: ?`Dado un grafo conexo $G$, tiene $G$ un circuito hamiltoniano?
% \ei
% \end{frame}

% \begin{frame}
%   \titulos{Problema del agente viajero {\bf PAV}}{Algunos problemas {\bf NP}-completos}
% \bi
% \item Se tienen dadas $m$ ciudades, las distancias entre cualesquiera dos de
%   ellas y un entero $N$.\espc
  
%   \item {\bf PAV}: ?`Existe un recorrido que visite cada ciudad
%     exactamente una vez y cuya longitud sea menor o igual que $N$ ?
% \ei
% \end{frame}



\end{document}




%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "fcem7"
%%% End: 
