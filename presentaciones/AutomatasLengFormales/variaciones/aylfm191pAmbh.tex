%\documentclass[xcolor=dvipsnames]{beamer}
\documentclass[xcolor=dvipsnames,handout]{beamer}

\input{macros2006}

\newcommand{\titulos}[2]{\frametitle{#1}\framesubtitle{#2}}
\newcommand{\espc}{\vspace{.5cm}}
\newcommand{\U}{\mathcal{U}}
\newcommand{\cv}{\ensuremath{\varepsilon}}
\newcommand{\sest}{\ensuremath{\Sigma^\star}}
\newtheorem{teorema}{Teorema}
\renewcommand{\S}{\Sigma}
\newcommand{\de}{\delta}
\newcommand{\izq}{\leftarrow}
\newcommand{\der}{\rightarrow}
\newcommand{\dest}{\ensuremath{\delta^\star}}


\mode<presentation>
{
\usetheme[secheader]{Boadilla}
%\useinnertheme{rounded}
\useoutertheme{infolines}
%\usepackage{BeamerColor}
%\usecolortheme[RGB={33,66,33}]{structure}
\usecolortheme[named=NavyBlue]{structure}
%\usefonttheme{}
\setbeamercovered{invisible}
%\setbeamertemplate{headline}{\insertshortinstitute}
%\setbeamertemplate{footline}[page number]{\insertshortinstitute}
%\insertshortinstitute
}

\usepackage[spanish]{babel}
\usepackage[latin1]{inputenc}
\usepackage{times}
\usepackage[T1]{fontenc}


\title[AyLF MCIC 2019-I]{Autómatas y Lenguajes Formales 2019-I}
\subtitle
{Maestría en Ciencia e Ingeniería de la Computación UNAM\\
  Tema 8: Ambigüedad en gramáticas libres de contexto}

\author[Favio E. Miranda Perea]{Dr. Favio Ezequiel Miranda Perea \\ \texttt{favio@ciencias.unam.mx}}


\institute[FC UNAM]{Facultad de Ciencias UNAM}

\date{\today}

\subject{Theoretical Computer Science}

% \pgfdeclareimage[height=0.5cm]{LogoTecBueno}{LogoTecBueno.eps}
\logo{\includegraphics[height=1cm]{fc2.png}}

\begin{document}


\beamerdefaultoverlayspecification{<+->}

\begin{frame}
  \titlepage
\end{frame}






%\subsection{Jerarquía de Chomsky}

% \begin{frame}
%   \titulos{Lenguajes recursivamente enumerables o tipo
%     0}{Jerarquía de Chomsky}
%   Son aquellos lenguajes generados por una gramática sin restricciones
%   adicionales.\\
%   Tales gramáticas pueden incluir reglas de la forma
%   \beqs
%   \alert{\al\imp\cv}
%   \eeqs
%   De manera que la gramática es capaz de borrar cadenas. \pause Tales
%   gramáticas se conocen como \alert{contraibles}.\\
% Ejemplo:
% \beqs
% aS\imp bSb,\; aSb\imp \cv,\; SbS\imp bcS
%   \eeqs
% \end{frame}


% \begin{frame}
%   \titulos{Lenguajes recursivamente enumerables o tipo
%     0}{Jerarquía de Chomsky}
% \bi
% \item La siguiente es una gramática de tipo 0:
% \[
% S\to AT\;\;\;\;\;\;A\to 0AO\;\;\;\;A\to 1AI\;\;\;\;O0\to 0O
% \]
% \[
% O1\to 1O\;\;\;\;\;I0\to 0I\;\;\;\;\;I1\to1I\;\;\;\;\;OT\to 0T
% \]
% \[
% IT\to 1T\;\;\;\;\;\alert{A\to\varepsilon}\;\;\;\;\;\alert{T\to\varepsilon}
% \]
% \medskip
% \item $L(G)=\{ww\mid w\in\{0,1\}^\star\}$
% \medskip
% \item La idea del diseño de esta gramática y la razón del nombre {\em recursivamente enumerable} se discutirán más adelante.
% \ei
% \end{frame}



% \begin{frame}
%   \titulos{Lenguajes dependientes del contexto o tipo 1}{Jerarquía de
%     Chomsky}
%   Son aquellos generados por gramáticas con todas sus producciones son de la forma
%   \beqs
% \alert{\al_1A\al_2\imp\al_1\beta\al_2}
%   \eeqs
%   con $\al_1,\al_2\in(V\cup T)^\star,\;A\in V,\;\beta\neq\cv$.\\
  
%   Con la posible excepción de la regla $S\imp\cv$, en cuyo caso se
%   prohibe la presencia de $S$ a la derecha de las producciones.\\
% \pause  Por ejemplo la siguiente gramática dependiente del contexto genera al
% lenguaje $L=\{a^ib^ic^i\;|\;i\geq 0\}$
%   \beqs
%   S\imp A\;\;\;
%   A\imp aABC\;|\;abC\;\;\;
%       CB\imp BC \eeqs
%    \beqs bB\imp bb
%          \;\;\;bC\imp bc
%          \;\;\;cC\imp cc
%          \eeqs
% \end{frame}


% \begin{frame}
%   \titulos{Lenguajes libres del contexto o tipo 2}{Jerarquía de
%     Chomsky}
% \bi
% \item   Son aquellos generados por gramáticas con todas sus producciones de
%   la forma
%   \beqs
%   \alert{A\imp\al}
%   \eeqs
%   con $A\in V,\;\al\in(V\cup T)^\star$.\medskip
% \item  Esta definición incluye a la regla $S\imp\cv$. \medskip
% \item   La mayoría de las gramáticas para lenguajes de programación caen en
%   esta categoría.
% \ei
% \end{frame}

% \begin{frame}
%   \titulos{Lenguajes regulares o tipo 3}{Jerarquía de Chomsky}
%   Son aquellos generados por una gramática de una de las siguientes
%   formas:
%   \bi
%   \item Lineal por la derecha: todas las producciones de la forma
%     \beqs
%     \alert{A\imp aB\;\;\;A\imp a\;\;\;A\imp\cv}
%     \eeqs
%     con $A,B\in V,\;a\in T$
  
%   \item Lineas por la izquierda: todas las producciones de la forma
%        \beqs
%     \alert{A\imp Ba\;\;\;A\imp a\;\;\;A\imp\cv}
%     \eeqs
%     con $A,B\in V,\;a\in T$
% \item No se permite mezclar ambos tipos de producciones.
%   \ei
%   \end{frame}

%   \begin{frame}
%     \titulos{Jerarquía de Chomsky}{Observaciones}
%     \bi
%     \item Decimos que un lenguaje es de tipo $i$ si y sólo si $i$ es el índice mas grande tal que existe una gramática de tipo $i$ que genera a $L$
% % la gramática con
% %       índice más mayor que lo genera es de tipo $i$.
%       \item La jerarquía de gramáticas genera una jerarquía en los
%         lenguajes generados:
%         \beqs
%         \alert{\mathcal{L}_3\subsetneq \mathcal{L}_2\subsetneq \mathcal{L}_1\subsetneq \mathcal{L}_0}
%         \eeqs
%         \item La jerarquía de Chomsky permite refinar la teoría de la
%           computación clasificando lenguajes en función de los
%           recursos computacionales necesarios para reconocerlos.
%     \ei
    
%   \end{frame}


%\section{Gramáticas Regulares}

%\subsection{Introducción}
%\begin{frame}
%  \titulos{Gramáticas Regulares}{Definición}
%    \bi
%  \item Lineal por la derecha: todas las producciones de la forma
%    \beqs
%    \alert{A\imp aB\;\;\;A\imp a\;\;\;A\imp\cv}
%    \eeqs
%    con $A,B\in V,\;a\in T$
  
%  \item Lineas por la izquierda: todas las producciones de la forma
%       \beqs
%    \alert{A\imp Ba\;\;\;A\imp a\;\;\;A\imp\cv}
%    \eeqs
%    con $A,B\in V,\;a\in T$
%\ei
%No se permite mezclar ambos tipos de producciones.
%\end{frame}




% \begin{frame}
%   \titulos{Gramáticas Regulares}{}
%     \bi
%   \item Una gramática regular es una gramática lineal por la
%     derecha o lineal por la izquierda.\espc
%    \item  No se permite mezclar ambos tipos de producciones.\espc
%      \item Se puede probar que toda gramática lineal por la izquierda
%        es equivalente a una gramática lineal por la derecha.
%        \ei
%        \end{frame}
%        \begin{frame}
%   \titulos{Gramáticas Regulares}{Lenguajes Regulares}
%        \bi
%        \item Decimos que un lenguaje $L$ es regular si \alert{existe} una
%          gramática regular $G$  que lo genere, es decir, si 
%          $L=L(G)$.\espc
%          \item Si $L$ es generado por una gramática de tipo $i$, no se puede
%            asegurar de inmediato que $L$ sea un lenguaje de tipo
%            $i$. Debe asegurarse que $i$ es máximo.
% \ei
% \end{frame}

% %\subsection{Ejemplos}
% \begin{frame}
%   \titulos{$L=0^\star10^\star 10^\star$}{Ejemplos}
%   $L$ es generado por:
%   \beqs
%  \ba{rll}
%  S & \imp & A1A1A \\
%  A & \imp & 0A\;|\;\cv
%  \ea
% \eeqs
% esta gramática no es regular, \pause pero el lenguaje si lo es al existir una
% gramática regular equivalente:
% \beqs
%  \ba{rll}
%  S & \imp & 0S\;|\;1A \\
%  A & \imp & 0A\;|\;1B \\
%  B & \imp & 0B\;|\;\cv \\
%  \ea
% \eeqs
% \end{frame}


% \begin{frame}
%   \titulos{$L=(a+b)^\star b$}{Ejemplos}
%   $L$ es generado por:

% \beqs
%  \ba{rll}
%  S & \imp & aS\;|\;bC \\
%  C & \imp & bC\;|\;aS\;|\;\cv\\
%  \ea
% \eeqs
% \end{frame}

% %\subsection{AF $\;\Iff\;$ GR}
% \begin{frame}
%   \titulos{Lenguajes y gramáticas regulares}{AF$\;\Imp\;$ GR}
%   Dado un AF  $M=\pt{Q,\S,\de,q_0,F}$ existe una gramática regular
%   $G=\pt{V,T,S,P}$ tal que $L(M)=L(G)$. Es decir, todo lenguaje
%   regular es generado por una gramática regular.\pause\\
%   Definimos a $G$ como sigue:
%   \bi
%   \item Suponemos s.p.g. que no hay $\cv$-transiciones.
%     \item $V=Q\;\;\;\;\;T=\S\;\;\;S=q_0$
%              \item $P$ se define como sigue:
%           \bi
%           \item Si $p\in\de(q,a)$ entonces
%             agregamos $q\imp ap$ a $P$.\espc
%             \item Si $q_f\in\de(q,a)$ con $q_f\in F$ entonces
%               agregamos $q\imp a$.
%            % \item Si $q_F\in F$ entonces agregamos $q_F\imp\cv$ a $P$.
%           \ei
%   \ei
% \end{frame}



%\begin{frame}
%  Por ejemplo, para el autómata $M$ dado por: 
%\beqs
%\VCDraw{
%\begin{VCPicture}{(0,0)(6,3)}  
%\State[q_0]{(0,3)}{q_0} \State[q_1]{(3,3)}{q_1}
%\FinalState[q_2]{(6,0)}{q_2} 
%\Initial{q_0} %\Final{q_3}
%\EdgeL{q_0}{q_1}{1}\ArcR{q_1}{q_2}{0}\ArcR{q_2}{q_1}{1}
%\ArcL{q_2}{q_0}{0} %\ArcL{q_2}{q_0}{a}
%\LoopN{q_0}{0} \LoopN{q_1}{1} %\LoopS{q_2}{a,b}
%\end{VCPicture}
%}
%\eeqs
%La gramática obtenida es:
%\beqs
%q_0\imp 0q_0\;|\;1q_1\;\;\;\;\;q_1\imp
%1q_1\;|\;0q_2\;|\;0\;\;\;\;\;\;q_2\imp 0q_0\;|\;1q_1
%\eeqs

%\end{frame}
  
%\begin{frame}


%Para el autómata $M$:


%  \beqs
%\VCDraw{
%\begin{VCPicture}{(0,0)(3,3)}  
%\FinalState[q_0]{(0,3)}{q_0} \FinalState[q_1]{(3,3)}{q_1}
%\State[q_2]{(3,0)}{q_2} 
%\Initial{q_0} %\Final{q_3}
%\ArcL{q_0}{q_1}{b}\ArcL{q_1}{q_0}{a}\ArcL{q_1}{q_2}{b}
%\ArcL{q_2}{q_1}{b}\ArcL{q_2}{q_0}{a}
%\LoopN{q_0}{a} %\LoopN{q_1}{b}\LoopS{q_2}{a,b}
%\end{VCPicture}
%}
%\eeqs

%la gramática generada es:


%\beqs
%q_0\imp aq_0\;|\;bq_1\;|\;a\;|\;b\;\;\;\;q_1\imp
%aq_0\;|\;bq_2\;|\;a\;\;\;\;q_2\imp aq_0\;|\;bq_1\;|\;a
%\eeqs
%\end{frame}







\begin{frame}
  \titulos{Árboles de derivación}{GLC}
  \bi
  \item Los árboles de derivación o árboles sintácticos son un
    mecanismo para representar las derivaciones de gramáticas libres
    de contexto.\espc
  \item  En compiladores se utilizan para el análisis sintáctico de
    programas fuente (parsing) y sirven de base para la generación de
    código.\espc
    \item Puede ser que dos derivaciones distintas tengan el mismo
      árbol.
\ei
    \end{frame}



\begin{frame}
  \titulos{Construcción de árboles de derivación}{GLC}
  Dada una gramática libre de contexto $G=\pt{V,T,S,P}$, un árbol de
  derivación en $G$ se construye como sigue: \pause
\bi
\item La raiz contiene al símbolo inicial $S$.
\item Cada nodo interior contiene una variable
  \item Cada hoja contiene un símbolo de $V\cup T\cup\{\cv\}$.
    \item Si un nodo interior contiene una variable $A$ entonces sus
      hijos contienen símbolos (de izquierda a derecha)
      $a_1,\ldots,a_n$ si y sólo si $A\imp a_1a_2\ldots a_n$ está en
      $P$.
      \item La palabra generada se puede leer al leer las hojas de
        izquierda a derecha.
\ei
\end{frame}

%\subsection{Ambigüedad}

\begin{frame}
  \titulos{Árboles de derivación}{GLC}
  \bi
    \item Puede haber mas de un árbol de derivación para una cadena.\espc
      \item Lo ideal es que cada cadena tenga sólo un árbol asociado,
        esto implica que el lenguaje no es ambiguo.\espc
        \item Desafortunadamente existen lenguajes ambiguos.
  \ei
\end{frame}


\begin{frame}
  \titulos{Ambigüedad}{GLC}
  \bi
  \item Una gramática se dice \alert{ambigua} si existe una palabra
    $w$ con dos o más árboles de derivación distintos.
    \item En general una palabra puede tener mas de una derivación,
      pero un sólo árbol, en tal caso no hay ambigüedad.
      \item Algunas veces se puede suprimir la ambigüedad
        directamente.
        \item Sin embargo no hay un algoritmo para remover ambigüedad.
          \item Pero aún, hay lenguajes cuya ambigüedad es inevitable.
  \ei
\end{frame}


\begin{frame}
  \titulos{Ejemplos}{Ambigüedad}
  \beqs
  S\imp AA\;\;\;A\imp aSa\;|\;a
  \eeqs
La palabra $a^5$ tiene las siguientes derivaciones:\pause
\bi
\item $S\imp AA\imp aA\imp aaSa\imp aaAAa\imp aaaAa\imp aaaaa$\espc
  \item $S\imp AA\imp aSaA\imp aAAaA\imp aaAaA\imp aaaaA\imp aaaaa $\espc
    \item Las dos derivaciones son por la izquierda y generan
      árboles distintos.
\ei
\end{frame}


\begin{frame}
  \titulos{Lenguajes Ambiguos}{Ambigüedad}
  \bi
  \item Un lenguaje $L$ es ambiguo si existe una gramática ambigua $G$
    que genera a $L$.
    \item $L=\{a^{2+3i}\;|\;i\geq 0\}$ es ambiguo.\espc
    \item Un lenguaje es inherentemente ambiguo si todas las
      gramáticas que lo generan son ambiguas.
      \item $L=\{a^nb^nc^md^m\;|\;n,m\geq
        1\}\cup\{a^nb^mc^md^n\;|\;n,m\geq 1\}$ es inherentemente
        ambiguo.
        \ei
\end{frame}

\begin{frame}
  \titulos{$L=\{a^{2+3i}\;|\;i\geq 0\}$}{Lenguajes ambiguos}
  \bi
\item[] $L$ es ambiguo por se generado por la gramática ambigua \beqs
  S\imp AA\;\;\;A\imp aSa\;|\;a
  \eeqs
\item[] Sin embargo este lenguaje también es generado por una gramática no
ambigua:
\beqs
S\imp aa\;|\;aaU\;\;\;\;\;\;U\imp aaaU\;|\;aaa
\eeqs
\item[] en este caso la derivación de $a^5$ es:
\beqs
S\imp aaU\imp aaaaa
\eeqs
\item[] por lo tanto $L$ no es un lenguaje inherentemente ambiguo
\ei
\end{frame}

\begin{frame}
  \titulos{$L=\{a^nb^nc^md^m\;|\;n,m\geq
        1\}\cup\{a^nb^mc^md^n\;|\;n,m\geq 1\}$}{Lenguajes
        inherentemente ambigüos}
\bi
\item[] $L$ es generado por la gramática:
\beqs
\ba{l}
S\imp AB\;|\;C\;\;\;\;A\imp aAb\;|\;ab\;\;\;\;B\imp cBd\;|\;cd \\
C\imp aCd\;|\; aDd\;\;\;\;\; D\imp bDc\;|\;bc
\ea
\eeqs
\item[] La cadena $aabbccdd$ tiene dos derivaciones por la izquierda:
\item[] $S\imp AB\imp aAbB\imp aabbB\imp aabbcBd\imp aabbccdd$
\item[] $S\imp C\imp aCd\imp aaDdd\imp aabDcdd\imp aabbccdd$
\item[] Probar la ambiguedad inherente es complicado.  
\ei
\end{frame}



\begin{frame}
\titulos{Ambigüedad}{}
\bi
\item  Está probado que no puede existir un algoritmo que determine con certeza si una gramática es
ambigua o no, y que en tal caso elimine dicha ambigüedad produciendo una
gramática no ambigua equivalente a la original. 
\item Es decir, el problema de ambigüedad es indecidible. Lo más que se
sabe es que hay ciertas condiciones que determinan ambigüedad pero en
caso de no cumplirse éstas nada puede decirse de la gramática en
cuestión.
\item En algunos casos, dada una gramática ambigua, se puede encontrar otra
gramática equivalente no ambigua, por ejemplo agregando precedencia de
operadores y asociatividad. 
\item Sin embargo existen lenguajes cuya
ambigüedad es inevitable.
\ei
\end{frame}
 

\begin{frame}
\titulos{Paréntesis balanceados}{Eliminación de la ambigüedad}
  \bi 

\item Paréntesis balanceados:
\beqs
S \to \cv\;|\;(S)\;|\;SS
\eeqs
\item Ambigüedad: $()()()$ tiene dos árboles de derivación %es ambigua pero equivalente a la siguientes gramática no ambigua:
\item Gramática no ambigua equivalente:
\beqs
S \to \cv\;|\;(S)S
\eeqs
\ei
\end{frame}
\begin{frame}
\titulos{Expresiones aritméticas}{Eliminación de la ambigüedad}
\bi
\item Expresiones aritméticas: % este lenguaje es generado por la siguiente
  % gramática ambigua
\beqs
S \to S + S\;|\;S*S\;|\;(S)\mid a
\eeqs
donde $a$ es un terminal que representa a los identificadores y constantes.
\item Ambigüedad: a + a * a

\item Gramática no ambigua equivalente:  se obtiene modelando la precedencia de
operadores como sigue:
\beqs
\ba{rll}
S & \to & S+T\;|\;T \\
T & \to & T*F\;|\;F\\
F & \to & (S)\;|\;a
\ea
\eeqs
\ei
\end{frame}

\begin{frame}[fragile]
\titulos{Expresiones condicionales}{Eliminación de la ambigüedad}
\bi
\item Expresiones condicionales:
\beqs
\ba{rll}
S & \to & C\;|\;O\\
C & \to & {\tt if}\;E\;{\tt then}\;S \;|\; %\\
              %&    & 
{\tt if}\;E\;{\tt then}\;S\;{\tt else}\;S
\ea
\eeqs
\item Problema del {\tt if} colgante (dangling else, {\sc Algol} 60):
\begin{verbatim}
if a then if b then s1 else s2
\end{verbatim}
\item Dos significados:
\begin{verbatim}
if a then (if b then s1) else s2

if a then (if b then s1 else s2)
\end{verbatim}
\ei
\end{frame}

\begin{frame}[fragile]
\titulos{Expresiones condicionales}{Eliminación de la ambigüedad}
\bi
\item Una gramática equivalente no ambigua es:
\beqs
\ba{rll}
S & \to & C\;|\;O\\
C & \to & C1\;|\;C2\\
C1 & \to & {\tt if}\;E\;{\tt then}\;C1\;{\tt else}\;C1  \\
C2 & \to   & {\tt if}\;E\;{\tt then}\;S\;|\; %\\
%   & & 
{\tt if}\;E\;{\tt then}\;C1\;{\tt else}\;C2
\ea
\eeqs
\item Idea: $C1$ genera condicionales dobles (if-then-else) balanceados; $C2$ representa condicionales
simples (if-then) y condicionales dobles pero de forma que un if-then sólo figura colgando \\ al final (en el else). %único lugar donde puede quedar un condicional sencillo es en la condición else.
\ei
\end{frame}


\begin{frame}
\titulos{Gramáticas libres de contexto en lenguajes de programación}{}
\bi
\item  El estudio formal de los lenguajes de programación se divide en sintaxis, pragmática y semántica.
\item La semántica se encarga de definir el significado de las expresiones, enunciados
y unidades de programa.
\item La pragmática define la implementación del lenguaje basada en la metodología y estrategias de programación deseadas
\item La sintaxis se encarga de definir la forma de
las expresiones y enunciados de un lenguaje y se sirve fundamentalmente de los
conceptos y herramientas de nuestro curso. 
\item Antes del proceso de evaluación, un compilador e intérprete necesita realizar
los procesos de análisis léxico y sintáctico, describimos a
continuación a grandes rasgos.
\ei
\end{frame}


\begin{frame}
\titulos{Análisis léxico y sintáctico}{}
\bi
\item Análisis léxico: se encarga de transformar el programa fuente en una
  lista de unidades sintácticas de bajo nivel llamadas lexemas, los cuales se
  clasifican en distintas categorías llamadas {\em tokens}, como pueden ser
  identificadores, constantes, separadores, etc. 
\item El análisis léxico se sirve
  fundamentalmente de expresiones regulares para su definición y reconocimiento.
\item Análisis sintáctico: se encarga de transformar la lista de lexemas en un
  programa objeto, el cual es una 
  expresión válida de la llamada sintaxis abstracta del lenguaje. Este
  programa es esencialmente un árbol de derivación dictado por
  una gramática libre de contexto que define al lenguaje de programación. 
\item Por
  lo tanto el análisis sintáctico es esencialmente una forma del problema de
  la pertenencia en gramáticas libres de contexto.
\ei
\end{frame}

\begin{frame}
\titulos{Forma de Backus-Naur}{}  
\bi
\item Las gramáticas libres de contexto para lenguajes de programación suelen
escribirse en la forma de Backus-Naur o BNF.
\item Este método de definición de gramáticas fue introducido por John Backus para el lenguaje {\sc Algol} 58 en 1959 y fue mejorado por Peter Naur para la definición de {\sc Algol} 60.
\item Este sistema notacional para definir lenguajes libres de contexto 
 sigue las siguientes convenciones:

\bi
\item El símbolo de reescritura $\to$ se reemplaza con $::=$.\medskip
\item El símbolo $\mid$ significa {\em o} y abreviar la definición de producciones de una misma variable.\medskip
\item Las variables se escriben entre paréntesis triangulares y por lo general
  utilizan nombres largos que ayuden a la descripción de \\ las categorías del lenguaje.
\ei
\ei
\end{frame}


\begin{frame}
\titulos{Gramáticas en forma de Backus-Naur}{Ejemplos}

\bi
\item Lenguaje de paréntesis balanceados
\beqs
\ba{rll}
<parent\_balanc> & ::= & \cv \;|\; \\
                 & & (<parent\_balanc>)\;|\; \\
                 & & <parent\_balanc><parent\_balanc> 
\ea
\eeqs
\item Expresiones aritméticas:
\beqs
\ba{rll}
<expr> & ::= & <expr>\,<op>\,<expr>\;|\; \\
       & & (<expr>)\;|\;<id>\\
<op> & := & +\;|\;-\;|\;*\;|\;/\\
<id> & := & a\;|\;b\;|\;c
\ea
\eeqs
\ei
\end{frame}

\begin{frame}
\titulos{Bloques de asignación de expresiones aritméticas:}
{{\tt begin}\;a {\tt :=} b/c\; ; \; b {\tt :=} a*(b+c)\;{\tt end}}
%{Gramáticas en forma de Backus-Naur}
\beqs
\ba{rll}
<programa> & ::= & {\tt begin}\;<sec\_enunc>\;{\tt end}\\ \\
<sec\_enunc> & ::= & <enunc>\;|\;<enunc>\,;\,<sec\_enunc>\\ \\
<enunc> & ::= & <id>\;{\tt :=}\;<expr>\\ \\
<expr> & ::= & <expr>\,<op>\,<expr>\;|\; \\ \\
       & & (<expr>)\;|\;<id>\\ \\
<op> & := & +\;|\;-\;|\;*\;|\;/\\ \\
<id> & := & a\;|\;b\;|\;c
\ea
\eeqs


\end{frame}

\begin{frame}[fragile]
\titulos{Gramáticas en forma de Backus-Naur}{Ejemplos}
\bi
\item Expresiones condicionales:
\beqs
\ba{rll}
<enunc> & ::= & <condicional>\;|\;<otras>\\
<condicional> & := & {\tt if}\;<expr>\;{\tt then}\;<enunc> \;|\; \\
              &    & {\tt if}\;<expr>\;{\tt then}\;<enunc> \\
              &    & \;{\tt            else}\;<enunc>
\ea
\eeqs
% \item Problema del {\tt if} colgante:
% \begin{verbatim}
% if false then if false then 0 else 1
% \end{verbatim}
% \item Dos significados:
% \begin{verbatim}
% if false then (if false then 0) else 1
% if false then (if false then 0 else 1)
% \end{verbatim}
%\ec
\ei
\end{frame}






\end{document}
  
%%% Local Variables: 
%%% mode: latex
%%% TeX-master: "fcem7"
%%% End: 
